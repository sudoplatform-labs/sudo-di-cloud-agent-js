/**
 * Sudo Decentralized Identity Cloud Agent SDK
 * Provides REST API wrappers for Typescript Agent Controllers using the Sudo Decentralized Identity Cloud Agent Service
 *
 * The version of the OpenAPI document: v0.6.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from '../runtime';
import {
  GetDIDEndpointResponse,
  GetDIDEndpointResponseFromJSON,
  GetDIDEndpointResponseToJSON,
  GetDIDVerkeyResponse,
  GetDIDVerkeyResponseFromJSON,
  GetDIDVerkeyResponseToJSON,
  GetNymRoleResponse,
  GetNymRoleResponseFromJSON,
  GetNymRoleResponseToJSON,
  LedgerConfigList,
  LedgerConfigListFromJSON,
  LedgerConfigListToJSON,
  TAAAccept,
  TAAAcceptFromJSON,
  TAAAcceptToJSON,
  TAAResult,
  TAAResultFromJSON,
  TAAResultToJSON,
  TxnOrRegisterLedgerNymResponse,
  TxnOrRegisterLedgerNymResponseFromJSON,
  TxnOrRegisterLedgerNymResponseToJSON,
  WriteLedgerRequest,
  WriteLedgerRequestFromJSON,
  WriteLedgerRequestToJSON,
} from '../models';

export interface LedgerDidEndpointGetRequest {
  did: string;
  endpointType?: LedgerDidEndpointGetEndpointTypeEnum;
}

export interface LedgerDidVerkeyGetRequest {
  did: string;
}

export interface LedgerGetNymRoleGetRequest {
  did: string;
}

export interface LedgerRegisterNymPostRequest {
  did: string;
  verkey: string;
  alias?: string;
  connId?: string;
  createTransactionForEndorser?: boolean;
  role?: LedgerRegisterNymPostRoleEnum;
}

export interface LedgerTaaAcceptPostRequest {
  body?: TAAAccept;
}

/**
 *
 */
export class LedgerApi extends runtime.BaseAPI {
  /**
   * Get the endpoint for a DID from the ledger.
   */
  async ledgerDidEndpointGetRaw(
    requestParameters: LedgerDidEndpointGetRequest,
  ): Promise<runtime.ApiResponse<GetDIDEndpointResponse>> {
    if (requestParameters.did === null || requestParameters.did === undefined) {
      throw new runtime.RequiredError(
        'did',
        'Required parameter requestParameters.did was null or undefined when calling ledgerDidEndpointGet.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.did !== undefined) {
      queryParameters['did'] = requestParameters.did;
    }

    if (requestParameters.endpointType !== undefined) {
      queryParameters['endpoint_type'] = requestParameters.endpointType;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request({
      path: `/ledger/did-endpoint`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    });

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      GetDIDEndpointResponseFromJSON(jsonValue),
    );
  }

  /**
   * Get the endpoint for a DID from the ledger.
   */
  async ledgerDidEndpointGet(
    requestParameters: LedgerDidEndpointGetRequest,
  ): Promise<GetDIDEndpointResponse> {
    const response = await this.ledgerDidEndpointGetRaw(requestParameters);
    return await response.value();
  }

  /**
   * Get the verkey for a DID from the ledger.
   */
  async ledgerDidVerkeyGetRaw(
    requestParameters: LedgerDidVerkeyGetRequest,
  ): Promise<runtime.ApiResponse<GetDIDVerkeyResponse>> {
    if (requestParameters.did === null || requestParameters.did === undefined) {
      throw new runtime.RequiredError(
        'did',
        'Required parameter requestParameters.did was null or undefined when calling ledgerDidVerkeyGet.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.did !== undefined) {
      queryParameters['did'] = requestParameters.did;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request({
      path: `/ledger/did-verkey`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    });

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      GetDIDVerkeyResponseFromJSON(jsonValue),
    );
  }

  /**
   * Get the verkey for a DID from the ledger.
   */
  async ledgerDidVerkeyGet(
    requestParameters: LedgerDidVerkeyGetRequest,
  ): Promise<GetDIDVerkeyResponse> {
    const response = await this.ledgerDidVerkeyGetRaw(requestParameters);
    return await response.value();
  }

  /**
   * Get the role from the NYM registration of a public DID.
   */
  async ledgerGetNymRoleGetRaw(
    requestParameters: LedgerGetNymRoleGetRequest,
  ): Promise<runtime.ApiResponse<GetNymRoleResponse>> {
    if (requestParameters.did === null || requestParameters.did === undefined) {
      throw new runtime.RequiredError(
        'did',
        'Required parameter requestParameters.did was null or undefined when calling ledgerGetNymRoleGet.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.did !== undefined) {
      queryParameters['did'] = requestParameters.did;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request({
      path: `/ledger/get-nym-role`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    });

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      GetNymRoleResponseFromJSON(jsonValue),
    );
  }

  /**
   * Get the role from the NYM registration of a public DID.
   */
  async ledgerGetNymRoleGet(
    requestParameters: LedgerGetNymRoleGetRequest,
  ): Promise<GetNymRoleResponse> {
    const response = await this.ledgerGetNymRoleGetRaw(requestParameters);
    return await response.value();
  }

  /**
   * Fetch the multiple ledger configuration currently in use
   */
  async ledgerMultipleConfigGetRaw(): Promise<
    runtime.ApiResponse<LedgerConfigList>
  > {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request({
      path: `/ledger/multiple/config`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    });

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      LedgerConfigListFromJSON(jsonValue),
    );
  }

  /**
   * Fetch the multiple ledger configuration currently in use
   */
  async ledgerMultipleConfigGet(): Promise<LedgerConfigList> {
    const response = await this.ledgerMultipleConfigGetRaw();
    return await response.value();
  }

  /**
   * Fetch the current write ledger
   */
  async ledgerMultipleGetWriteLedgerGetRaw(): Promise<
    runtime.ApiResponse<WriteLedgerRequest>
  > {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request({
      path: `/ledger/multiple/get-write-ledger`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    });

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      WriteLedgerRequestFromJSON(jsonValue),
    );
  }

  /**
   * Fetch the current write ledger
   */
  async ledgerMultipleGetWriteLedgerGet(): Promise<WriteLedgerRequest> {
    const response = await this.ledgerMultipleGetWriteLedgerGetRaw();
    return await response.value();
  }

  /**
   * Send a NYM registration to the ledger.
   */
  async ledgerRegisterNymPostRaw(
    requestParameters: LedgerRegisterNymPostRequest,
  ): Promise<runtime.ApiResponse<TxnOrRegisterLedgerNymResponse>> {
    if (requestParameters.did === null || requestParameters.did === undefined) {
      throw new runtime.RequiredError(
        'did',
        'Required parameter requestParameters.did was null or undefined when calling ledgerRegisterNymPost.',
      );
    }

    if (
      requestParameters.verkey === null ||
      requestParameters.verkey === undefined
    ) {
      throw new runtime.RequiredError(
        'verkey',
        'Required parameter requestParameters.verkey was null or undefined when calling ledgerRegisterNymPost.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.did !== undefined) {
      queryParameters['did'] = requestParameters.did;
    }

    if (requestParameters.verkey !== undefined) {
      queryParameters['verkey'] = requestParameters.verkey;
    }

    if (requestParameters.alias !== undefined) {
      queryParameters['alias'] = requestParameters.alias;
    }

    if (requestParameters.connId !== undefined) {
      queryParameters['conn_id'] = requestParameters.connId;
    }

    if (requestParameters.createTransactionForEndorser !== undefined) {
      queryParameters['create_transaction_for_endorser'] =
        requestParameters.createTransactionForEndorser;
    }

    if (requestParameters.role !== undefined) {
      queryParameters['role'] = requestParameters.role;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request({
      path: `/ledger/register-nym`,
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
    });

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      TxnOrRegisterLedgerNymResponseFromJSON(jsonValue),
    );
  }

  /**
   * Send a NYM registration to the ledger.
   */
  async ledgerRegisterNymPost(
    requestParameters: LedgerRegisterNymPostRequest,
  ): Promise<TxnOrRegisterLedgerNymResponse> {
    const response = await this.ledgerRegisterNymPostRaw(requestParameters);
    return await response.value();
  }

  /**
   * Rotate key pair for public DID.
   */
  async ledgerRotatePublicDidKeypairPatchRaw(): Promise<
    runtime.ApiResponse<object>
  > {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request({
      path: `/ledger/rotate-public-did-keypair`,
      method: 'PATCH',
      headers: headerParameters,
      query: queryParameters,
    });

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * Rotate key pair for public DID.
   */
  async ledgerRotatePublicDidKeypairPatch(): Promise<object> {
    const response = await this.ledgerRotatePublicDidKeypairPatchRaw();
    return await response.value();
  }

  /**
   * Accept the transaction author agreement
   */
  async ledgerTaaAcceptPostRaw(
    requestParameters: LedgerTaaAcceptPostRequest,
  ): Promise<runtime.ApiResponse<object>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request({
      path: `/ledger/taa/accept`,
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: TAAAcceptToJSON(requestParameters.body),
    });

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * Accept the transaction author agreement
   */
  async ledgerTaaAcceptPost(
    requestParameters: LedgerTaaAcceptPostRequest,
  ): Promise<object> {
    const response = await this.ledgerTaaAcceptPostRaw(requestParameters);
    return await response.value();
  }

  /**
   * Fetch the current transaction author agreement, if any
   */
  async ledgerTaaGetRaw(): Promise<runtime.ApiResponse<TAAResult>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request({
      path: `/ledger/taa`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    });

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      TAAResultFromJSON(jsonValue),
    );
  }

  /**
   * Fetch the current transaction author agreement, if any
   */
  async ledgerTaaGet(): Promise<TAAResult> {
    const response = await this.ledgerTaaGetRaw();
    return await response.value();
  }
}

/**
 * @export
 * @enum {string}
 */
export enum LedgerDidEndpointGetEndpointTypeEnum {
  Endpoint = 'Endpoint',
  Profile = 'Profile',
  LinkedDomains = 'LinkedDomains',
}
/**
 * @export
 * @enum {string}
 */
export enum LedgerRegisterNymPostRoleEnum {
  Steward = 'STEWARD',
  Trustee = 'TRUSTEE',
  Endorser = 'ENDORSER',
  NetworkMonitor = 'NETWORK_MONITOR',
  Reset = 'reset',
}
